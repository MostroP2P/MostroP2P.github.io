<!-- Animated network mesh background — canvas-based with individual node movement -->
<canvas id="network-canvas" aria-hidden="true"></canvas>

<style>
  #network-canvas {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 0;
  }

  @media (prefers-reduced-motion: reduce) {
    #network-canvas {
      display: none;
    }
  }
</style>

<script>
  const canvas = document.getElementById('network-canvas') as HTMLCanvasElement;
  const ctx = canvas.getContext('2d')!;

  let W = 0;
  let H = 0;
  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  // Network config
  const NODE_DENSITY = 0.000045; // nodes per px²
  const CONNECTION_DIST = 220;
  const NODE_RADIUS_MIN = 1.2;
  const NODE_RADIUS_MAX = 2.8;
  const LINE_OPACITY = 0.12;
  const NODE_OPACITY = 0.35;
  const ACCENT = { r: 140, g: 198, b: 63 }; // #8CC63F

  // Speed: 1.5x base. Base drift cycle ~80s, node wander ~53s equivalent
  const DRIFT_SPEED = 0.00012; // global drift
  const NODE_SPEED_MIN = 0.08;
  const NODE_SPEED_MAX = 0.25;

  interface Node {
    x: number;       // current x
    y: number;       // current y
    bx: number;      // base x (home position)
    by: number;      // base y
    r: number;       // radius
    vx: number;      // wander velocity x
    vy: number;      // wander velocity y
    wanderRange: number;
    phase: number;   // phase offset for organic motion
    freq: number;    // frequency multiplier
  }

  let nodes: Node[] = [];
  let driftX = 0;
  let driftY = 0;
  let driftAngle = 0;

  function resize() {
    W = window.innerWidth;
    H = window.innerHeight;
    canvas.width = W * DPR;
    canvas.height = H * DPR;
    canvas.style.width = W + 'px';
    canvas.style.height = H + 'px';
    ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    generateNodes();
  }

  function generateNodes() {
    const count = Math.floor(W * H * NODE_DENSITY);
    nodes = [];
    for (let i = 0; i < count; i++) {
      const x = Math.random() * (W + 100) - 50;
      const y = Math.random() * (H + 100) - 50;
      const speed = NODE_SPEED_MIN + Math.random() * (NODE_SPEED_MAX - NODE_SPEED_MIN);
      const angle = Math.random() * Math.PI * 2;
      nodes.push({
        x, y,
        bx: x, by: y,
        r: NODE_RADIUS_MIN + Math.random() * (NODE_RADIUS_MAX - NODE_RADIUS_MIN),
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        wanderRange: 25 + Math.random() * 40,
        phase: Math.random() * Math.PI * 2,
        freq: 0.3 + Math.random() * 0.7,
      });
    }
  }

  function update(time: number) {
    const t = time * 0.001; // seconds

    // Global drift (slow movement of the whole mesh)
    driftX = Math.sin(t * DRIFT_SPEED * 800) * 18 + Math.cos(t * DRIFT_SPEED * 500) * 12;
    driftY = Math.cos(t * DRIFT_SPEED * 600) * 15 + Math.sin(t * DRIFT_SPEED * 400) * 10;

    // Update each node's position with organic wandering
    for (const n of nodes) {
      const wt = t * n.freq;
      n.x = n.bx + Math.sin(wt + n.phase) * n.wanderRange * 0.6
           + Math.cos(wt * 0.7 + n.phase * 1.3) * n.wanderRange * 0.4;
      n.y = n.by + Math.cos(wt * 0.8 + n.phase * 0.7) * n.wanderRange * 0.6
           + Math.sin(wt * 0.6 + n.phase * 1.1) * n.wanderRange * 0.4;
    }
  }

  function draw() {
    ctx.clearRect(0, 0, W, H);
    ctx.save();
    ctx.translate(driftX, driftY);

    const connDist2 = CONNECTION_DIST * CONNECTION_DIST;

    // Draw connections
    for (let i = 0; i < nodes.length; i++) {
      const a = nodes[i];
      for (let j = i + 1; j < nodes.length; j++) {
        const b = nodes[j];
        const dx = a.x - b.x;
        const dy = a.y - b.y;
        const d2 = dx * dx + dy * dy;
        if (d2 < connDist2) {
          const dist = Math.sqrt(d2);
          const alpha = (1 - dist / CONNECTION_DIST) * LINE_OPACITY;
          ctx.beginPath();
          ctx.moveTo(a.x, a.y);
          ctx.lineTo(b.x, b.y);
          ctx.strokeStyle = `rgba(${ACCENT.r}, ${ACCENT.g}, ${ACCENT.b}, ${alpha})`;
          ctx.lineWidth = 0.6;
          ctx.stroke();
        }
      }
    }

    // Draw nodes
    for (const n of nodes) {
      ctx.beginPath();
      ctx.arc(n.x, n.y, n.r, 0, Math.PI * 2);
      ctx.fillStyle = `rgba(${ACCENT.r}, ${ACCENT.g}, ${ACCENT.b}, ${NODE_OPACITY})`;
      ctx.fill();
    }

    ctx.restore();
  }

  function loop(time: number) {
    update(time);
    draw();
    requestAnimationFrame(loop);
  }

  // Throttle resize
  let resizeTimer: ReturnType<typeof setTimeout>;
  window.addEventListener('resize', () => {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(resize, 200);
  });

  resize();
  requestAnimationFrame(loop);
</script>
